# 시간 복잡도 (java)

## 시간 복잡도란?!🤔

- 주어진 문제를 해결하기 위한 연산 횟수
- 일반적으로 수행 시간은 1억 번의 연산을 1초의 시간으로 간주하여 예측
    - ex) 시간 제한 2초 → 2억번의 연산 안에 답이 나와야 한다!

## 시간 복잡도 정의

- **Big-O(빅-오)** : **최선**일 때의 연산 횟수를 나타낸 표기법, 상한 점근
- **Big-θ(빅-세타)** : **최악**일 때의 연산 횟수를 나타낸 표기법, 하한 점근
- **Big-Ω(빅-오메가)** : **평균**일 때의 연산 횟수를 나타낸 표기법, 위 둘의 평균

예제를 살펴보자!

아래 코드는 0 ~ 99 사이의 랜덤값을 찾아 출력하는 코드이다.

```java
public class timeComplexityExample {
		public static void main(String[] args) {
				// 1 ~ 100 사이 값 랜덤 선택
				int findNumber = (int)(Math.random() * 100);
				for(int i = 0; i < 100; i++) {
						if(i == findNumber) {
								System.out.println(i);
								break;
						}
				}
		}
}
```

- 빅 오메가 표기법의 시간 복잡도 :  1 👉 한 번에 찾은 경우!!
- 빅-세타 표기법의 시간 복잡도 :  2/N번 👉 평균인 50 정도에서 찾은 경우!!
- 빅-오 표기법의 시간 복잡도 :  N번 👉 최악의 경우로 99가 나와 끝까지 다 도는 경우!!

## 코딩 테스트에서는 어떤 시간 복잡도 유형을 사용해야 할까?

**그렇다면 우리는 무엇을 기준으로 따져야 할까?!🤔** 

💡 바로, **Big-O(빅-오) 표기법!!**

가장 최악의 케이스를 염두하고 코딩테스트에 임해야 한다!!

왜냐? 다양한 테스트 케이스를 수행해 모든 케이스를 통과해야만 합격으로 판단하기 때문!

![image](https://github.com/funnysunny08/coding-test-java/assets/88873302/484822da-7c8b-4455-90d0-5febd4006e0f)

위는 시간 복잡도 속도 비교!

## 시간 복잡도 활용하기

시간 복잡도를 따질 때, **데이터의 개수를 봐라!!!**

예를 들어, 아래의 조건이 주어진 문제가 있다고 가정하자!

```
- n개의 수 정렬
- 1 ≤ N ≤ 1,000,000
- 제한 시간 2초
```

시간 제한이 2초이므로 이 조건을 만족하기 위해서는 **2억 번의 연산 횟수로** 문제를 해결해야 한다!

- 연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기

그렇다면 이제 적합성 평가!!! 👉 최댓값을 기준으로 시간 복잡도 따지기

- 버블 정렬 = O(N^2) → 부적합
- 병합 정렬 = NO(logN) → 적합

### 시간 복잡도를 바탕으로 코드 로직 개선하기

**시간 복잡도 도출 기준**

1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

O(N), O(3N) 모두 같다! 👉 O(N)

***코딩테스트 진행할 때***

1. 아는 문제이고 시간 복잡도에 맞는 알고리즘을 짰다
2. But, 답도 다 나오는데 시간 초과?!
3. 내 로직이 효율적으로 짜여 있는지 봐야 한다!!

시간 복잡도 이 원리를 바탕으로 문제가 되는 코드 부분을 도출할 수 있고, 이 부분을 연산에 더욱 효율적인 구조로 수정하는 작업으로 문제를 해결할 수 있다!!

## 자료 구조 최악의 시간 복잡도

![image](https://github.com/funnysunny08/coding-test-java/assets/88873302/b4d902c2-08d8-4039-a3fc-2d464ad3c88e)

---

### 📚 참고자료
- https://www.youtube.com/watch?v=XncTU-4i1KI&list=PLG7te9eYUi7tAQygBknaTciy8wzLCe-Ll&index=2